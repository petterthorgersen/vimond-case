{"version":3,"sources":["../../../../../../src/streaming/rules/synchronization/LiveEdgeBinarySearchRule.js"],"names":[],"mappings":"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","file":"LiveEdgeBinarySearchRule.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport SwitchRequest from '../SwitchRequest';\nimport EventBus from '../../../core/EventBus';\nimport Events from '../../../core/events/Events';\nimport FactoryMaker from '../../../core/FactoryMaker';\n\nconst SEARCH_TIME_SPAN = 12 * 60 * 60; // set the time span that limits our search range to a 12 hours in seconds\n\nfunction LiveEdgeBinarySearchRule(config) {\n\n    let context = this.context;\n    let eventBus = EventBus(context).getInstance();\n\n    let adapter = config.adapter;\n    let timelineConverter = config.timelineConverter;\n\n    let instance,\n        liveEdgeInitialSearchPosition,\n        liveEdgeSearchRange,\n        liveEdgeSearchStep,\n        representationInfo,\n        useBinarySearch,\n        fragmentDuration,\n        p,\n        callback,\n        fragmentLoader,\n        streamProcessor;\n\n    function setup() {\n        liveEdgeInitialSearchPosition = NaN;\n        liveEdgeSearchRange = null;\n        liveEdgeSearchStep = NaN;\n        representationInfo = null;\n        useBinarySearch = false;\n        fragmentDuration = NaN;\n        p = SwitchRequest.DEFAULT;\n    }\n\n    function execute(rulesContext, callbackFunc) {\n        var request,\n            DVRWindow; // all fragments are supposed to be available in this interval\n\n        callback = callbackFunc;\n        streamProcessor = rulesContext.getStreamProcessor();\n        fragmentLoader = streamProcessor.getFragmentLoader();\n        representationInfo = rulesContext.getTrackInfo();\n        fragmentDuration = representationInfo.fragmentDuration;\n        DVRWindow = representationInfo.DVRWindow; // all fragments are supposed to be available in this interval\n\n        // start position of the search, it is supposed to be a live edge - the last available fragment for the current mpd\n        liveEdgeInitialSearchPosition = DVRWindow.end;\n\n        if (representationInfo.useCalculatedLiveEdgeTime) {\n            //By default an expected live edge is the end of the last segment.\n            // A calculated live edge ('end' property of a range returned by TimelineConverter.calcSegmentAvailabilityRange)\n            // is used as an initial point for finding the actual live edge.\n            // But for SegmentTimeline mpds (w/o a negative @r) the end of the\n            // last segment is the actual live edge. At the same time, calculated live edge is an expected live edge.\n            // Thus, we need to switch an expected live edge and actual live edge for SegmentTimeline streams.\n            var actualLiveEdge = timelineConverter.getExpectedLiveEdge();\n            timelineConverter.setExpectedLiveEdge(liveEdgeInitialSearchPosition);\n            callback(SwitchRequest(context).create(actualLiveEdge, p));\n            return;\n        }\n\n        // we should search for a live edge in a time range which is limited by SEARCH_TIME_SPAN.\n        liveEdgeSearchRange = {start: Math.max(0, (liveEdgeInitialSearchPosition - SEARCH_TIME_SPAN)), end: liveEdgeInitialSearchPosition + SEARCH_TIME_SPAN};\n        // we have to use half of the availability interval (window) as a search step to ensure that we find a fragment in the window\n        liveEdgeSearchStep = Math.floor((DVRWindow.end - DVRWindow.start) / 2);\n        // start search from finding a request for the initial search time\n        request = adapter.getFragmentRequestForTime(streamProcessor, representationInfo, liveEdgeInitialSearchPosition, {ignoreIsFinished: true});\n        findLiveEdge(liveEdgeInitialSearchPosition, onSearchForFragmentSucceeded, onSearchForFragmentFailed, request);\n    }\n\n    function reset() {\n        liveEdgeInitialSearchPosition = NaN;\n        liveEdgeSearchRange = null;\n        liveEdgeSearchStep = NaN;\n        representationInfo = null;\n        useBinarySearch = false;\n        fragmentDuration = NaN;\n        streamProcessor = null;\n        fragmentLoader = null;\n    }\n\n    function findLiveEdge(searchTime, onSuccess, onError, request) {\n        var req;\n        if (request === null) {\n            // request can be null because it is out of the generated list of request. In this case we need to\n            // update the list and the DVRWindow\n            // try to get request object again\n            req = adapter.generateFragmentRequestForTime(streamProcessor, representationInfo, searchTime);\n            findLiveEdge(searchTime, onSuccess, onError, req);\n        } else {\n            var handler = function (e) {\n                eventBus.off(Events.CHECK_FOR_EXISTENCE_COMPLETED, handler, this);\n                if (e.exists) {\n                    onSuccess(e.request, searchTime);\n                } else {\n                    onError(e.request, searchTime);\n                }\n            };\n\n            eventBus.on(Events.CHECK_FOR_EXISTENCE_COMPLETED, handler, this);\n            fragmentLoader.checkForExistence(request);\n        }\n    }\n\n    function onSearchForFragmentFailed(request, lastSearchTime) {\n        var searchTime,\n            req,\n            searchInterval;\n\n        if (useBinarySearch) {\n            binarySearch(false, lastSearchTime);\n            return;\n        }\n\n        // we have not found any available fragments yet, update the search interval\n        searchInterval = lastSearchTime - liveEdgeInitialSearchPosition;\n        // we search forward and backward from the start position, increasing the search interval by the value of the half of the availability interval - liveEdgeSearchStep\n        searchTime = searchInterval > 0 ? (liveEdgeInitialSearchPosition - searchInterval) : (liveEdgeInitialSearchPosition + Math.abs(searchInterval) + liveEdgeSearchStep);\n\n        // if the search time is out of the range bounds we have not be able to find live edge, stop trying\n        if (searchTime < liveEdgeSearchRange.start && searchTime > liveEdgeSearchRange.end) {\n            callback(SwitchRequest(context).create(null, p));\n        } else {\n            // continue searching for a first available fragment\n            req = adapter.getFragmentRequestForTime(streamProcessor, representationInfo, searchTime, {ignoreIsFinished: true});\n            findLiveEdge(searchTime, onSearchForFragmentSucceeded, onSearchForFragmentFailed, req);\n        }\n    }\n\n    function onSearchForFragmentSucceeded(request, lastSearchTime) {\n        var startTime = request.startTime;\n        var req,\n            searchTime;\n\n        if (!useBinarySearch) {\n            // if the fragment duration is unknown we cannot use binary search because we will not be able to\n            // decide when to stop the search, so let the start time of the current fragment be a liveEdge\n            if (!representationInfo.fragmentDuration) {\n                callback(SwitchRequest(context).create(startTime, p));\n                return;\n            }\n            useBinarySearch = true;\n            liveEdgeSearchRange.end = startTime + (2 * liveEdgeSearchStep);\n\n            //if the first request has succeeded we should check next fragment - if it does not exist we have found live edge,\n            // otherwise start binary search to find live edge\n            if (lastSearchTime === liveEdgeInitialSearchPosition) {\n                searchTime = lastSearchTime + fragmentDuration;\n                req = adapter.getFragmentRequestForTime(streamProcessor, representationInfo, searchTime, {ignoreIsFinished: true});\n                findLiveEdge(searchTime, function () {\n                    binarySearch(true, searchTime);\n                }, function () {\n                    callback(SwitchRequest(context).create(searchTime, p));\n                }, req);\n\n                return;\n            }\n        }\n\n        binarySearch(true, lastSearchTime);\n    }\n\n    function binarySearch(lastSearchSucceeded, lastSearchTime) {\n        var isSearchCompleted,\n            req,\n            searchTime;\n\n        if (lastSearchSucceeded) {\n            liveEdgeSearchRange.start = lastSearchTime;\n        } else {\n            liveEdgeSearchRange.end = lastSearchTime;\n        }\n\n        isSearchCompleted = (Math.floor(liveEdgeSearchRange.end - liveEdgeSearchRange.start)) <= fragmentDuration;\n\n        if (isSearchCompleted) {\n            // search completed, we should take the time of the last found fragment. If the last search succeeded we\n            // take this time. Otherwise, we should subtract the time of the search step which is equal to fragment duration\n            callback(SwitchRequest(context).create((lastSearchSucceeded ? lastSearchTime : (lastSearchTime - fragmentDuration)), p));\n        } else {\n            // update the search time and continue searching\n            searchTime = ((liveEdgeSearchRange.start + liveEdgeSearchRange.end) / 2);\n            req = adapter.getFragmentRequestForTime(streamProcessor, representationInfo, searchTime, {ignoreIsFinished: true});\n            findLiveEdge(searchTime, onSearchForFragmentSucceeded, onSearchForFragmentFailed, req);\n        }\n    }\n\n    instance = {\n        execute: execute,\n        reset: reset\n    };\n\n    setup();\n\n    return instance;\n}\n\nLiveEdgeBinarySearchRule.__dashjs_factory_name = 'LiveEdgeBinarySearchRule';\nexport default FactoryMaker.getClassFactory(LiveEdgeBinarySearchRule);"]}